// SPDX-License-Identifier: MPL-2.0
// SPDX-FileCopyrightText: 2026 Aryan Ameri <info@ameri.me>
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

/**
 * Environment file generation for multi-container stacks.
 * Generates grouped environment files with comments.
 */

import { Array as Arr, Match, Option, Predicate, pipe } from "effect";

/** Characters requiring quoting in shell environment values */
const ENV_SPECIAL_CHARS = [" ", '"', "'", "$", "`", "\\", "\n"] as const;

/**
 * Environment variable group.
 */
export interface EnvGroup {
  /** Group name (used in comment) */
  name: string;
  /** Environment variables */
  vars: Record<string, string | number | boolean | undefined>;
}

/**
 * Environment file configuration.
 */
export interface EnvFileConfig {
  /** Header comment */
  header?: string | undefined;
  /** Variable groups */
  groups: EnvGroup[];
}

/**
 * Type-safe value-to-string conversion.
 */
const formatValue = (value: string | number | boolean): string =>
  Match.value(value).pipe(
    Match.when(Match.boolean, (b) => (b ? "true" : "false")),
    Match.orElse((v) => String(v))
  );

/**
 * Unquote and unescape a parsed env value.
 */
const unquoteAndUnescape = (value: string): string => {
  const unquoted =
    (value.startsWith('"') && value.endsWith('"')) || (value.startsWith("'") && value.endsWith("'"))
      ? value.slice(1, -1)
      : value;

  return unquoted
    .replace(/\\n/g, "\n")
    .replace(/\\"/g, '"')
    .replace(/\\\$/g, "$")
    .replace(/\\`/g, "`")
    .replace(/\\\\/g, "\\");
};

/**
 * Escape a value for environment file format.
 */
export const escapeEnvValue = (value: string): string =>
  Arr.some(ENV_SPECIAL_CHARS, (char) => value.includes(char))
    ? `"${value
        .replace(/\\/g, "\\\\")
        .replace(/"/g, '\\"')
        .replace(/\$/g, "\\$")
        .replace(/`/g, "\\`")
        .replace(/\n/g, "\\n")}"`
    : value;

/**
 * Format a single environment variable line.
 */
export const formatEnvLine = (key: string, value: string | number | boolean): string =>
  `${key}=${escapeEnvValue(formatValue(value))}`;

/**
 * Generate an environment file with grouped variables.
 */
export const generateEnvFile = (config: EnvFileConfig): string => {
  const headerLines = pipe(
    Option.fromNullable(config.header),
    Option.map((h) => [
      `# ${h}`,
      "# Generated by divban - DO NOT EDIT MANUALLY",
      `# Generated at: ${new Date().toISOString()}`,
      "",
    ]),
    Option.getOrElse((): string[] => [])
  );

  const groupLines = pipe(
    config.groups,
    Arr.flatMap((group) => {
      const entries = pipe(
        Object.entries(group.vars),
        Arr.filterMap(([key, value]) =>
          pipe(
            Option.fromNullable(value),
            Option.map((v) => formatEnvLine(key, v))
          )
        )
      );

      return Arr.isEmptyArray(entries)
        ? []
        : [`# ${group.name}`, `# ${"â”€".repeat(40)}`, ...entries, ""];
    })
  );

  return [...headerLines, ...groupLines].join("\n");
};

/**
 * Generate an environment file from a flat record.
 */
export const generateSimpleEnvFile = (
  vars: Record<string, string | number | boolean | undefined>,
  header?: string
): string => {
  return generateEnvFile({
    header,
    groups: [{ name: "Environment Variables", vars }],
  });
};

/**
 * Parse an environment file into a record.
 */
export const parseEnvFile = (content: string): Record<string, string> =>
  pipe(
    content.split("\n"),
    Arr.map((line) => line.trim()),
    Arr.filter((line) => line.length > 0 && !line.startsWith("#")),
    Arr.filterMap((line) => {
      const eqIndex = line.indexOf("=");
      return eqIndex === -1
        ? Option.none()
        : Option.some([
            line.slice(0, eqIndex),
            unquoteAndUnescape(line.slice(eqIndex + 1)),
          ] as const);
    }),
    Object.fromEntries
  );

/**
 * Merge multiple environment records.
 */
export const mergeEnv = (
  ...envs: (Record<string, string | number | boolean | undefined> | undefined)[]
): Record<string, string> =>
  pipe(
    envs,
    Arr.filter(Predicate.isNotNullable),
    Arr.flatMap(Object.entries),
    Arr.filterMap(([key, value]) =>
      pipe(
        Option.fromNullable(value),
        Option.map((v) => [key, formatValue(v)] as const)
      )
    ),
    Object.fromEntries
  );

/**
 * Create common environment groups.
 */
export const CommonEnvGroups: Record<
  string,
  (config: Record<string, string | number | undefined>) => EnvGroup
> = {
  /** Database connection */
  database: (config: {
    host?: string;
    port?: number;
    name?: string;
    user?: string;
    password?: string;
  }): EnvGroup => ({
    name: "Database Configuration",
    vars: {
      DB_HOST: config.host,
      DB_PORT: config.port,
      DB_NAME: config.name,
      DB_USERNAME: config.user,
      DB_PASSWORD: config.password,
    },
  }),

  /** Redis connection */
  redis: (config: { host?: string; port?: number; password?: string }): EnvGroup => ({
    name: "Redis Configuration",
    vars: {
      REDIS_HOST: config.host,
      REDIS_PORT: config.port,
      REDIS_PASSWORD: config.password,
    },
  }),

  /** Basic server config */
  server: (config: { host?: string; port?: number; publicUrl?: string }): EnvGroup => ({
    name: "Server Configuration",
    vars: {
      HOST: config.host,
      PORT: config.port,
      PUBLIC_URL: config.publicUrl,
    },
  }),
};
