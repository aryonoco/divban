// SPDX-License-Identifier: MPL-2.0
// SPDX-FileCopyrightText: 2026 Aryan Ameri <info@ameri.me>
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

/**
 * Environment file generation and parsing. Shell-sensitive characters
 * are escaped via `envEscapeCodec` to ensure round-trip fidelity.
 * Variables are organised into named groups for readable output.
 */

import { Array as Arr, Match, Option, Predicate, pipe } from "effect";
import { envEscapeCodec } from "../lib/escape-codec";

/** Characters that require the value to be double-quoted in shell env files. */
const ENV_SPECIAL_CHARS = [" ", '"', "'", "$", "`", "\\", "\n"] as const;

export interface EnvGroup {
  name: string;
  vars: Record<string, string | number | boolean | undefined>;
}

export interface EnvFileConfig {
  header?: string | undefined;
  groups: EnvGroup[];
}

const formatValue = (value: string | number | boolean): string =>
  Match.value(value).pipe(
    Match.when(Match.boolean, (b) => (b ? "true" : "false")),
    Match.orElse((v) => String(v))
  );

/** Strip surrounding quotes then unescape the inner content. */
const unquoteAndUnescape = (value: string): string => {
  const unquoted =
    (value.startsWith('"') && value.endsWith('"')) || (value.startsWith("'") && value.endsWith("'"))
      ? value.slice(1, -1)
      : value;

  return envEscapeCodec.unescape(unquoted);
};

export const escapeEnvValue = (value: string): string => {
  if (!Arr.some(ENV_SPECIAL_CHARS, (char) => value.includes(char))) {
    return value;
  }
  const escaped = envEscapeCodec.escape(value);
  return `"${escaped}"`;
};

export const formatEnvLine = (key: string, value: string | number | boolean): string =>
  `${key}=${escapeEnvValue(formatValue(value))}`;

export const generateEnvFile = (config: EnvFileConfig): string => {
  const headerLines = pipe(
    Option.fromNullable(config.header),
    Option.map((h) => [
      `# ${h}`,
      "# Generated by divban - DO NOT EDIT MANUALLY",
      `# Generated at: ${new Date().toISOString()}`,
      "",
    ]),
    Option.getOrElse((): string[] => [])
  );

  const groupLines = pipe(
    config.groups,
    Arr.flatMap((group) => {
      const entries = pipe(
        Object.entries(group.vars),
        Arr.filterMap(([key, value]) =>
          pipe(
            Option.fromNullable(value),
            Option.map((v) => formatEnvLine(key, v))
          )
        )
      );

      return Arr.isEmptyArray(entries)
        ? []
        : [`# ${group.name}`, `# ${"â”€".repeat(40)}`, ...entries, ""];
    })
  );

  return [...headerLines, ...groupLines].join("\n");
};

/** Convenience wrapper: wraps a flat record into a single unnamed group. */
export const generateSimpleEnvFile = (
  vars: Record<string, string | number | boolean | undefined>,
  header?: string
): string => {
  return generateEnvFile({
    header,
    groups: [{ name: "Environment Variables", vars }],
  });
};

export const parseEnvFile = (content: string): Record<string, string> =>
  pipe(
    content.split("\n"),
    Arr.map((line) => line.trim()),
    Arr.filter((line) => line.length > 0 && !line.startsWith("#")),
    Arr.filterMap((line) => {
      const eqIndex = line.indexOf("=");
      return eqIndex === -1
        ? Option.none()
        : Option.some([
            line.slice(0, eqIndex),
            unquoteAndUnescape(line.slice(eqIndex + 1)),
          ] as const);
    }),
    Object.fromEntries
  );

/** Merge multiple env records, dropping `undefined` values. Later entries win. */
export const mergeEnv = (
  ...envs: (Record<string, string | number | boolean | undefined> | undefined)[]
): Record<string, string> =>
  pipe(
    envs,
    Arr.filter(Predicate.isNotNullable),
    Arr.flatMap(Object.entries),
    Arr.filterMap(([key, value]) =>
      pipe(
        Option.fromNullable(value),
        Option.map((v) => [key, formatValue(v)] as const)
      )
    ),
    Object.fromEntries
  );

/** Pre-built group factories for common service dependencies. */
export const CommonEnvGroups: Record<
  string,
  (config: Record<string, string | number | undefined>) => EnvGroup
> = {
  database: (config: {
    host?: string;
    port?: number;
    name?: string;
    user?: string;
    password?: string;
  }): EnvGroup => ({
    name: "Database Configuration",
    vars: {
      DB_HOST: config.host,
      DB_PORT: config.port,
      DB_NAME: config.name,
      DB_USERNAME: config.user,
      DB_PASSWORD: config.password,
    },
  }),

  redis: (config: { host?: string; port?: number; password?: string }): EnvGroup => ({
    name: "Redis Configuration",
    vars: {
      REDIS_HOST: config.host,
      REDIS_PORT: config.port,
      REDIS_PASSWORD: config.password,
    },
  }),

  server: (config: { host?: string; port?: number; publicUrl?: string }): EnvGroup => ({
    name: "Server Configuration",
    vars: {
      HOST: config.host,
      PORT: config.port,
      PUBLIC_URL: config.publicUrl,
    },
  }),
};
