// SPDX-License-Identifier: MPL-2.0
// SPDX-FileCopyrightText: 2026 Aryan Ameri <info@ameri.me>
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

import { Schema } from "effect";
import { absolutePathSchema } from "../../config/schema";
import type {
  ContainerLocation,
  ContainerLocationInput,
  DatabaseName,
  DatabaseUser,
  PostgresBackupConfig,
} from "../../lib/db-backup";
import {
  ContainerLocationSchema,
  DatabaseNameSchema,
  DatabaseUserSchema,
} from "../../lib/db-backup";
import { isValidIP, isValidUrl } from "../../lib/schema-utils";
import type { AbsolutePath } from "../../lib/types";
import {
  type DivbanConfigSchemaVersion,
  DivbanConfigSchemaVersionSchema,
} from "../../lib/versioning";
import { CONTAINERS, DEFAULT_IMAGES } from "./constants";

export type TranscodingConfig =
  | { readonly type: "nvenc"; readonly gpuIndex?: number | undefined }
  | { readonly type: "qsv"; readonly renderDevice?: string | undefined }
  | { readonly type: "vaapi"; readonly renderDevice?: string | undefined }
  | { readonly type: "vaapi-wsl" }
  | { readonly type: "rkmpp" }
  | { readonly type: "disabled" };

export const transcodingConfigSchema: Schema.Schema<TranscodingConfig> = Schema.Union(
  Schema.Struct({
    type: Schema.Literal("nvenc"),
    gpuIndex: Schema.optional(Schema.Number.pipe(Schema.int(), Schema.greaterThanOrEqualTo(0))),
  }),
  Schema.Struct({
    type: Schema.Literal("qsv"),
    renderDevice: Schema.optional(Schema.String),
  }),
  Schema.Struct({
    type: Schema.Literal("vaapi"),
    renderDevice: Schema.optional(Schema.String),
  }),
  Schema.Struct({ type: Schema.Literal("vaapi-wsl") }),
  Schema.Struct({ type: Schema.Literal("rkmpp") }),
  Schema.Struct({ type: Schema.Literal("disabled") })
);

export type MlConfig =
  | { readonly type: "cuda"; readonly gpuIndex?: number | undefined }
  | { readonly type: "openvino"; readonly device?: "CPU" | "GPU" | "AUTO" | undefined }
  | { readonly type: "armnn" }
  | { readonly type: "rknn" }
  | { readonly type: "rocm"; readonly gfxVersion?: string | undefined }
  | { readonly type: "disabled" };

export const mlConfigSchema: Schema.Schema<MlConfig> = Schema.Union(
  Schema.Struct({
    type: Schema.Literal("cuda"),
    gpuIndex: Schema.optional(Schema.Number.pipe(Schema.int(), Schema.greaterThanOrEqualTo(0))),
  }),
  Schema.Struct({
    type: Schema.Literal("openvino"),
    device: Schema.optional(Schema.Literal("CPU", "GPU", "AUTO")),
  }),
  Schema.Struct({ type: Schema.Literal("armnn") }),
  Schema.Struct({ type: Schema.Literal("rknn") }),
  Schema.Struct({
    type: Schema.Literal("rocm"),
    gfxVersion: Schema.optional(Schema.String),
  }),
  Schema.Struct({ type: Schema.Literal("disabled") })
);

export interface HardwareConfig {
  readonly transcoding: TranscodingConfig;
  readonly ml: MlConfig;
}

export interface HardwareConfigInput {
  readonly transcoding?: TranscodingConfig | undefined;
  readonly ml?: MlConfig | undefined;
}

export const hardwareSchema: Schema.Schema<HardwareConfig, HardwareConfigInput> = Schema.Struct({
  transcoding: Schema.optionalWith(transcodingConfigSchema, {
    default: (): TranscodingConfig => ({ type: "disabled" }),
  }),
  ml: Schema.optionalWith(mlConfigSchema, {
    default: (): MlConfig => ({ type: "disabled" }),
  }),
});

export interface ExternalLibrary {
  readonly path: AbsolutePath;
  readonly name?: string | undefined;
  readonly readOnly: boolean;
}

export interface ExternalLibraryInput {
  readonly path: string;
  readonly name?: string | undefined;
  readonly readOnly?: boolean | undefined;
}

export const externalLibrarySchema: Schema.Schema<ExternalLibrary, ExternalLibraryInput> =
  Schema.Struct({
    path: absolutePathSchema,
    name: Schema.optional(Schema.String),
    readOnly: Schema.optionalWith(Schema.Boolean, { default: (): boolean => true }),
  });

/** Password is auto-generated by divban during setup and injected via secret. */
export interface DatabaseConfig {
  readonly database: string;
  readonly username: string;
}

export interface DatabaseConfigInput {
  readonly database?: string | undefined;
  readonly username?: string | undefined;
}

export const databaseSchema: Schema.Schema<DatabaseConfig, DatabaseConfigInput> = Schema.Struct({
  database: Schema.optionalWith(Schema.String, { default: (): string => "immich" }),
  username: Schema.optionalWith(Schema.String, { default: (): string => "immich" }),
});

export interface ImmichContainersConfig {
  readonly server?: { readonly image: string } | undefined;
  readonly machineLearning?:
    | { readonly image?: string | undefined; readonly enabled: boolean }
    | undefined;
  readonly redis?: { readonly image: string } | undefined;
  readonly postgres?: { readonly image: string } | undefined;
}

export interface ImmichContainersConfigInput {
  readonly server?: { readonly image?: string | undefined } | undefined;
  readonly machineLearning?:
    | { readonly image?: string | undefined; readonly enabled?: boolean | undefined }
    | undefined;
  readonly redis?: { readonly image?: string | undefined } | undefined;
  readonly postgres?: { readonly image?: string | undefined } | undefined;
}

export const immichContainersSchema: Schema.Schema<
  ImmichContainersConfig,
  ImmichContainersConfigInput
> = Schema.Struct({
  server: Schema.optional(
    Schema.Struct({
      image: Schema.optionalWith(Schema.String, { default: (): string => DEFAULT_IMAGES.server }),
    })
  ),
  machineLearning: Schema.optional(
    Schema.Struct({
      image: Schema.optional(Schema.String), // Derived from ML backend
      enabled: Schema.optionalWith(Schema.Boolean, { default: (): boolean => true }),
    })
  ),
  redis: Schema.optional(
    Schema.Struct({
      image: Schema.optionalWith(Schema.String, { default: (): string => DEFAULT_IMAGES.redis }),
    })
  ),
  postgres: Schema.optional(
    Schema.Struct({
      image: Schema.optionalWith(Schema.String, { default: (): string => DEFAULT_IMAGES.postgres }),
    })
  ),
});

export interface ImmichNetworkConfig {
  readonly port: number;
  readonly host: string;
}

export interface ImmichNetworkConfigInput {
  readonly port?: number | undefined;
  readonly host?: string | undefined;
}

export const immichNetworkSchema: Schema.Schema<ImmichNetworkConfig, ImmichNetworkConfigInput> =
  Schema.Struct({
    port: Schema.optionalWith(Schema.Number.pipe(Schema.int(), Schema.between(1, 65535)), {
      default: (): number => 2283,
    }),
    host: Schema.optionalWith(
      Schema.String.pipe(Schema.filter(isValidIP, { message: (): string => "Invalid IP address" })),
      { default: (): string => "127.0.0.1" }
    ),
  });

export interface ImmichConfig {
  readonly divbanConfigSchemaVersion: DivbanConfigSchemaVersion;
  readonly paths: {
    readonly dataDir: AbsolutePath;
    readonly uploadDir?: AbsolutePath | undefined;
    readonly profileDir?: AbsolutePath | undefined;
    readonly thumbsDir?: AbsolutePath | undefined;
    readonly encodedDir?: AbsolutePath | undefined;
  };
  readonly database: DatabaseConfig;
  readonly hardware?: HardwareConfig | undefined;
  readonly externalLibraries?: readonly ExternalLibrary[] | undefined;
  readonly containers?: ImmichContainersConfig | undefined;
  readonly network?: ImmichNetworkConfig | undefined;
  readonly publicUrl?: string | undefined;
  readonly logLevel: "verbose" | "debug" | "log" | "warn" | "error";
  /** Backup configuration - PostgreSQL via container exec (hot backup safe) */
  readonly backup: PostgresBackupConfig;
}

/** Backup configuration input - optional since it has defaults */
export interface ImmichBackupConfigInput {
  readonly type?: "postgres" | undefined;
  readonly container?: ContainerLocationInput | undefined;
  readonly database?: string | undefined;
  readonly user?: string | undefined;
}

export interface ImmichConfigInput {
  readonly divbanConfigSchemaVersion: string;
  readonly paths: {
    readonly dataDir: string;
    readonly uploadDir?: string | undefined;
    readonly profileDir?: string | undefined;
    readonly thumbsDir?: string | undefined;
    readonly encodedDir?: string | undefined;
  };
  readonly database: DatabaseConfigInput;
  readonly hardware?: HardwareConfigInput | undefined;
  readonly externalLibraries?: readonly ExternalLibraryInput[] | undefined;
  readonly containers?: ImmichContainersConfigInput | undefined;
  readonly network?: ImmichNetworkConfigInput | undefined;
  readonly publicUrl?: string | undefined;
  readonly logLevel?: "verbose" | "debug" | "log" | "warn" | "error" | undefined;
  readonly backup?: ImmichBackupConfigInput | undefined;
}

const defaultBackupConfig = (): PostgresBackupConfig => ({
  type: "postgres",
  container: { kind: "separate", name: CONTAINERS.postgres },
  database: "immich" as DatabaseName,
  user: "immich" as DatabaseUser,
});

export const immichBackupConfigSchema: Schema.Schema<
  PostgresBackupConfig,
  ImmichBackupConfigInput
> = Schema.Struct({
  type: Schema.optionalWith(Schema.Literal("postgres"), {
    default: (): "postgres" => "postgres",
  }),
  container: Schema.optionalWith(ContainerLocationSchema, {
    default: (): ContainerLocation => ({ kind: "separate", name: CONTAINERS.postgres }),
  }),
  database: Schema.optionalWith(DatabaseNameSchema, {
    default: (): DatabaseName => "immich" as DatabaseName,
  }),
  user: Schema.optionalWith(DatabaseUserSchema, {
    default: (): DatabaseUser => "immich" as DatabaseUser,
  }),
});

export const immichConfigSchema: Schema.Schema<ImmichConfig, ImmichConfigInput> = Schema.Struct({
  divbanConfigSchemaVersion: DivbanConfigSchemaVersionSchema,
  paths: Schema.Struct({
    dataDir: absolutePathSchema,
    uploadDir: Schema.optional(absolutePathSchema),
    profileDir: Schema.optional(absolutePathSchema),
    thumbsDir: Schema.optional(absolutePathSchema),
    encodedDir: Schema.optional(absolutePathSchema),
  }),
  database: databaseSchema,
  hardware: Schema.optional(hardwareSchema),
  externalLibraries: Schema.optional(Schema.Array(externalLibrarySchema)),
  containers: Schema.optional(immichContainersSchema),
  network: Schema.optional(immichNetworkSchema),
  publicUrl: Schema.optional(
    Schema.String.pipe(Schema.filter(isValidUrl, { message: (): string => "Invalid URL" }))
  ),
  logLevel: Schema.optionalWith(Schema.Literal("verbose", "debug", "log", "warn", "error"), {
    default: (): "log" => "log",
  }),
  backup: Schema.optionalWith(immichBackupConfigSchema, { default: defaultBackupConfig }),
});
