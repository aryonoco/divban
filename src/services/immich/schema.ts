// SPDX-License-Identifier: MPL-2.0
// SPDX-FileCopyrightText: 2026 Aryan Ameri <info@ameri.me>
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

/**
 * Immich service configuration schema.
 */

import { Schema } from "effect";
import { absolutePathSchema } from "../../config/schema";
import { isValidIP, isValidUrl } from "../../lib/schema-utils";
import type { AbsolutePath } from "../../lib/types";
import { DEFAULT_IMAGES } from "./constants";

/**
 * Hardware acceleration configuration for video transcoding.
 */
export type TranscodingConfig =
  | { readonly type: "nvenc"; readonly gpuIndex?: number | undefined }
  | { readonly type: "qsv"; readonly renderDevice?: string | undefined }
  | { readonly type: "vaapi"; readonly renderDevice?: string | undefined }
  | { readonly type: "vaapi-wsl" }
  | { readonly type: "rkmpp" }
  | { readonly type: "disabled" };

export const transcodingConfigSchema: Schema.Schema<TranscodingConfig> = Schema.Union(
  Schema.Struct({
    type: Schema.Literal("nvenc"),
    gpuIndex: Schema.optional(Schema.Number.pipe(Schema.int(), Schema.greaterThanOrEqualTo(0))),
  }),
  Schema.Struct({
    type: Schema.Literal("qsv"),
    renderDevice: Schema.optional(Schema.String),
  }),
  Schema.Struct({
    type: Schema.Literal("vaapi"),
    renderDevice: Schema.optional(Schema.String),
  }),
  Schema.Struct({ type: Schema.Literal("vaapi-wsl") }),
  Schema.Struct({ type: Schema.Literal("rkmpp") }),
  Schema.Struct({ type: Schema.Literal("disabled") })
);

/**
 * Hardware acceleration configuration for machine learning.
 */
export type MlConfig =
  | { readonly type: "cuda"; readonly gpuIndex?: number | undefined }
  | { readonly type: "openvino"; readonly device?: "CPU" | "GPU" | "AUTO" | undefined }
  | { readonly type: "armnn" }
  | { readonly type: "rknn" }
  | { readonly type: "rocm"; readonly gfxVersion?: string | undefined }
  | { readonly type: "disabled" };

export const mlConfigSchema: Schema.Schema<MlConfig> = Schema.Union(
  Schema.Struct({
    type: Schema.Literal("cuda"),
    gpuIndex: Schema.optional(Schema.Number.pipe(Schema.int(), Schema.greaterThanOrEqualTo(0))),
  }),
  Schema.Struct({
    type: Schema.Literal("openvino"),
    device: Schema.optional(Schema.Literal("CPU", "GPU", "AUTO")),
  }),
  Schema.Struct({ type: Schema.Literal("armnn") }),
  Schema.Struct({ type: Schema.Literal("rknn") }),
  Schema.Struct({
    type: Schema.Literal("rocm"),
    gfxVersion: Schema.optional(Schema.String),
  }),
  Schema.Struct({ type: Schema.Literal("disabled") })
);

/**
 * Hardware acceleration configuration (output after decoding).
 */
export interface HardwareConfig {
  readonly transcoding: TranscodingConfig;
  readonly ml: MlConfig;
}

/**
 * Hardware acceleration configuration (input before decoding).
 */
export interface HardwareConfigInput {
  readonly transcoding?: TranscodingConfig | undefined;
  readonly ml?: MlConfig | undefined;
}

export const hardwareSchema: Schema.Schema<HardwareConfig, HardwareConfigInput> = Schema.Struct({
  transcoding: Schema.optionalWith(transcodingConfigSchema, {
    default: (): TranscodingConfig => ({ type: "disabled" }),
  }),
  ml: Schema.optionalWith(mlConfigSchema, {
    default: (): MlConfig => ({ type: "disabled" }),
  }),
});

/**
 * External library configuration (output after decoding).
 */
export interface ExternalLibrary {
  readonly path: AbsolutePath;
  readonly name?: string | undefined;
  readonly readOnly: boolean;
}

/**
 * External library configuration (input before decoding).
 */
export interface ExternalLibraryInput {
  readonly path: string;
  readonly name?: string | undefined;
  readonly readOnly?: boolean | undefined;
}

export const externalLibrarySchema: Schema.Schema<ExternalLibrary, ExternalLibraryInput> =
  Schema.Struct({
    path: absolutePathSchema,
    name: Schema.optional(Schema.String),
    readOnly: Schema.optionalWith(Schema.Boolean, { default: (): boolean => true }),
  });

/**
 * Database configuration (output after decoding).
 * Password is auto-generated by divban during setup.
 */
export interface DatabaseConfig {
  readonly database: string;
  readonly username: string;
}

/**
 * Database configuration (input before decoding).
 */
export interface DatabaseConfigInput {
  readonly database?: string | undefined;
  readonly username?: string | undefined;
}

export const databaseSchema: Schema.Schema<DatabaseConfig, DatabaseConfigInput> = Schema.Struct({
  database: Schema.optionalWith(Schema.String, { default: (): string => "immich" }),
  username: Schema.optionalWith(Schema.String, { default: (): string => "immich" }),
});

/**
 * Container-specific configuration (output after decoding).
 */
export interface ImmichContainersConfig {
  readonly server?: { readonly image: string } | undefined;
  readonly machineLearning?:
    | { readonly image?: string | undefined; readonly enabled: boolean }
    | undefined;
  readonly redis?: { readonly image: string } | undefined;
  readonly postgres?: { readonly image: string } | undefined;
}

/**
 * Container-specific configuration (input before decoding).
 */
export interface ImmichContainersConfigInput {
  readonly server?: { readonly image?: string | undefined } | undefined;
  readonly machineLearning?:
    | { readonly image?: string | undefined; readonly enabled?: boolean | undefined }
    | undefined;
  readonly redis?: { readonly image?: string | undefined } | undefined;
  readonly postgres?: { readonly image?: string | undefined } | undefined;
}

export const immichContainersSchema: Schema.Schema<
  ImmichContainersConfig,
  ImmichContainersConfigInput
> = Schema.Struct({
  server: Schema.optional(
    Schema.Struct({
      image: Schema.optionalWith(Schema.String, { default: (): string => DEFAULT_IMAGES.server }),
    })
  ),
  machineLearning: Schema.optional(
    Schema.Struct({
      image: Schema.optional(Schema.String), // Derived from ML backend
      enabled: Schema.optionalWith(Schema.Boolean, { default: (): boolean => true }),
    })
  ),
  redis: Schema.optional(
    Schema.Struct({
      image: Schema.optionalWith(Schema.String, { default: (): string => DEFAULT_IMAGES.redis }),
    })
  ),
  postgres: Schema.optional(
    Schema.Struct({
      image: Schema.optionalWith(Schema.String, { default: (): string => DEFAULT_IMAGES.postgres }),
    })
  ),
});

/**
 * Network configuration (output after decoding).
 */
export interface ImmichNetworkConfig {
  /** Host port to bind (default: 2283) */
  readonly port: number;
  /** Host IP to bind (default: 127.0.0.1 for security) */
  readonly host: string;
}

/**
 * Network configuration (input before decoding).
 */
export interface ImmichNetworkConfigInput {
  readonly port?: number | undefined;
  readonly host?: string | undefined;
}

export const immichNetworkSchema: Schema.Schema<ImmichNetworkConfig, ImmichNetworkConfigInput> =
  Schema.Struct({
    port: Schema.optionalWith(Schema.Number.pipe(Schema.int(), Schema.between(1, 65535)), {
      default: (): number => 2283,
    }),
    host: Schema.optionalWith(
      Schema.String.pipe(Schema.filter(isValidIP, { message: (): string => "Invalid IP address" })),
      { default: (): string => "127.0.0.1" }
    ),
  });

/**
 * Full Immich service configuration (output after decoding).
 */
export interface ImmichConfig {
  readonly paths: {
    readonly dataDir: AbsolutePath;
    readonly uploadDir?: AbsolutePath | undefined;
    readonly profileDir?: AbsolutePath | undefined;
    readonly thumbsDir?: AbsolutePath | undefined;
    readonly encodedDir?: AbsolutePath | undefined;
  };
  readonly database: DatabaseConfig;
  readonly hardware?: HardwareConfig | undefined;
  readonly externalLibraries?: readonly ExternalLibrary[] | undefined;
  readonly containers?: ImmichContainersConfig | undefined;
  readonly network?: ImmichNetworkConfig | undefined;
  readonly publicUrl?: string | undefined;
  readonly logLevel: "verbose" | "debug" | "log" | "warn" | "error";
}

/**
 * Full Immich service configuration (input before decoding).
 */
export interface ImmichConfigInput {
  readonly paths: {
    readonly dataDir: string;
    readonly uploadDir?: string | undefined;
    readonly profileDir?: string | undefined;
    readonly thumbsDir?: string | undefined;
    readonly encodedDir?: string | undefined;
  };
  readonly database: DatabaseConfigInput;
  readonly hardware?: HardwareConfigInput | undefined;
  readonly externalLibraries?: readonly ExternalLibraryInput[] | undefined;
  readonly containers?: ImmichContainersConfigInput | undefined;
  readonly network?: ImmichNetworkConfigInput | undefined;
  readonly publicUrl?: string | undefined;
  readonly logLevel?: "verbose" | "debug" | "log" | "warn" | "error" | undefined;
}

export const immichConfigSchema: Schema.Schema<ImmichConfig, ImmichConfigInput> = Schema.Struct({
  paths: Schema.Struct({
    dataDir: absolutePathSchema,
    uploadDir: Schema.optional(absolutePathSchema),
    profileDir: Schema.optional(absolutePathSchema),
    thumbsDir: Schema.optional(absolutePathSchema),
    encodedDir: Schema.optional(absolutePathSchema),
  }),
  database: databaseSchema,
  hardware: Schema.optional(hardwareSchema),
  externalLibraries: Schema.optional(Schema.Array(externalLibrarySchema)),
  containers: Schema.optional(immichContainersSchema),
  network: Schema.optional(immichNetworkSchema),
  publicUrl: Schema.optional(
    Schema.String.pipe(Schema.filter(isValidUrl, { message: (): string => "Invalid URL" }))
  ),
  logLevel: Schema.optionalWith(Schema.Literal("verbose", "debug", "log", "warn", "error"), {
    default: (): "log" => "log",
  }),
});
