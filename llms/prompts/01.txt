analyse this codebase in comprehensive details. Get a full understanding of its functionality,  modules, patterns and principles used. 

I have recently adopted the Effect library in this codebase and am moving from a combination of Zod + hand rolled FP-oriented facilities and combinators to fully adopting Effect as I'm finding the Effect library is quite good and very much in line with my software development principles (my background is in OCaml). 

Obviously Effect is a big library so I'm adopting it gradually across my codebase, replacing Zod and other hand crafted FP-inspired facilities with it . 

Read @llms/effect.llms.headline.txt 

To find more about a topic, you can read the full effect docs at llms/effect.llms.full.txt (this file is too big to fit in your context so grep for the relevant sections and read that) 

----


I have previously been provided with the following report. Read the Comprehensive Effect Adoption Report completely and in full. Analyse the relevant sections. 

--- 

I have already implemented the following: 
Priority 1: Effect Config
Priority 2: Schema.brand
I now want to implement 
Priority 3: Effect.retry with Schedule
Focus on 
Priority 3: Effect.retry with Schedule
Provide me with a full plan to completely and fully replace current code with the recommended approach from the report using Effect. 

Your plan should be complete. Once the plan is fully executed, there should be no sign of the legacy code left. No compatibility bridges or shims or wrappers. It should be a complete and clean refactor. 


----

Once you have all the information needed about the existing codebase and effect, tell me, what is the most logical part of Effect which I can adopt next which would provide the highest value to this codebase? 



I have already implemented parts of the recommendation. 
Examine what has already been done, what is left to do, and then provide me with an accurate updatged report. 

Your report should indicate exactly how Effect is already used, and it should provide a concrete set of next steps which I can take to fully adopt Effect across the codebase and truly leverage what this library provides. 


--- 

Find all regexps used in this codebase. 

Read @llms/effect.llms.headline.txt 

To find out the details of something in Effect, read the relevant parts of llms/effect.llms.full.txt (this file is too big to fit in your context so grep/search for the relevant sections and read those) 

Come up 

--- 


Refactor and rewrite everything in 
to eliminate all loops, minimise mutable data structures, eliminate throws and align it with FP principles 

Ensure the plan, as much as is practical, aligns with a "functional core, imperative shell" philosophy and railway oriented programming and uses classical FP concepts and idiomatic Effect patterns and is FP-aligned where practical and uses the features of the Effect library to achieve its goal where possible.

Read @llms/effect.llms.headline.txt 

To find out the details of something in Effect, read the relevant parts of llms/effect.llms.full.txt (this file is too big to fit in your context so grep/search for the relevant sections and read those) 

You can refactor or restructure any part of the codebase if required to avhieve this. You can refactor by merging or breaking existing modules if such an action would faclitate achiving better alignment with the principles discussed. 

--- 


Refine and enhance the plan
Ensure the plan fully leverages all the relevant facilities available in Effect

Read @llms/effect.llms.headline.txt 

To find out the details of something in Effect, read the relevant parts of llms/effect.llms.full.txt (this file is too big to fit in your context so grep/search for the relevant sections and read those) 


ensure your plan leverages as much of the existing codebase as possible, is DRY and aligns with software engineering best practices. Ensure the plan achieves maximal code reuse and code deduplication as much as possible. 

---

I still think the plan is not optimal. Refine and enhance the plan. 
Think like a senior Haskell/Ocaml developer. Ensure your plan aligns with how a senior haskell/ocaml programmer would structure the code, while also respecting my compiler setting @tsconfig.json and ensuring that your plan is compatible with these strict TypeScript settings (I will not be making my settings loose)

----

ensure the plan is exhaustive and idempotent. do not leave any decisions for later. Do the
  required investigation now and ensure the plan is deterministic and complete

---


Ensure your plan achieves a clean refactor, with no legacy code, compatibility bridges, deprecation notices or shims or wrappers letft behind. If there are breaking changes ensure all the callers and tests are updated instead. 

---

Â I still feel like there is a lot of duplication in

Think like a SRE level Haskell expert with a penchant for type theory, and then think very carefully and see if there is a way to restructure/refactor 
@src/quadlet/ 
in a more composable and FP-oriented way while still respecting my TS compiler settings @tsconfig.json