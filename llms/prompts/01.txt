analyse this codebase in comprehensive details. Get a full understanding of its functionality,  modules, patterns and principles used. 

I have recently adopted the Effect library in this codebase and am moving from a combination of Zod + hand rolled FP-oriented facilities and combinators to fully adopting Effect as I'm finding the Effect library is quite good and very much in line with my software development principles (my background is in OCaml). 

Obviously Effect is a big library so I'm adopting it gradually across my codebase, replacing Zod and other hand crafted FP-inspired facilities with it . 

Read @llms/effect.llms.headline.txt 

To find more about a topic, you can read the full effect docs at llms/effect.llms.full.txt (this file is too big to fit in your context so grep for the relevant sections and read that) 

----


I have previously been provided with the following report. Read the Comprehensive Effect Adoption Report completely and in full. Analyse the relevant sections. 

--- 

I have already implemented the following: 
Priority 1: Effect Config
Priority 2: Schema.brand
Priority 3: Effect.retry with Schedule
I now want to implement 
Priority 4: Effect Logging
Focus on 
Priority 4: Effect Logging
Provide me with a full plan to completely and fully replace current code with the recommended approach from the report using Effect. 

Your plan should be complete. Once the plan is fully executed, there should be no sign of the legacy code left. No compatibility bridges or shims or wrappers. It should be a complete and clean refactor. 


----

Once you have all the information needed about the existing codebase and effect, tell me, what is the most logical part of Effect which I can adopt next which would provide the highest value to this codebase? 



I have already implemented parts of the recommendation. 
Examine what has already been done, what is left to do, and then provide me with an accurate updatged report. 

Your report should indicate exactly how Effect is already used, and it should provide a concrete set of next steps which I can take to fully adopt Effect across the codebase and truly leverage what this library provides. 

--- 

Come up with a comprehensive, detailed, and accurate plan to completely refactor this codebase such that ALL dependency injection follows the recommended Context.Tag + Layer  pattern. You should think like a Haskell developer who is trying to implement `effectful` in a codebase but use TypsScript and the effect library to implement it instead. At the end of the implementation of the plan, all dependencies should be type checked at compile time and ServiceContext should be complettely removed with no legacy code, compatibility bridges, shims or wrappers left behind. 

--- 

Verify this plan fully achieves all of the following:

  - Provide Type-checked dependencies at compile time
  - No manual context threading
  - Layer memoization that prevents duplicate construction
  - Complete removal of ServiceContext
  - Fully leverages ALL of the relevant facilities provided by Effect library
  - Is DRY, follows idiomatic FP patterns, uses modern Effect features, and aligns with software engineering best practices  


To find out what Effect provides

Read @llms/effect.llms.headline.txt 

To find out the details of something in Effect, read the relevant parts of llms/effect.llms.full.txt (this file is too big to fit in your context so grep/search for the relevant sections and read those) 

--- 

Find all the instances in the codebase where a non-exhaustive conditional statment is used. An if statement or similar. 

To find out what Effect provides

Read @llms/effect.llms.headline.txt 

To find out the details of something in Effect, read the relevant parts of llms/effect.llms.full.txt (this file is too big to fit in your context so grep/search for the relevant sections and read those) 

Come up with a plan to eliminated every single non exhaustive conditional statement with an exhaustive patttern match using the facilities provided by Effect library. 

--- 


Refactor and rewrite everything in 
to eliminate all loops, minimise mutable data structures, eliminate throws and align it with FP principles 

Ensure the plan, as much as is practical, aligns with a "functional core, imperative shell" philosophy and railway oriented programming and uses classical FP concepts and idiomatic Effect patterns and is FP-aligned where practical and uses the features of the Effect library to achieve its goal where possible.

Read @llms/effect.llms.headline.txt 

To find out the details of something in Effect, read the relevant parts of llms/effect.llms.full.txt (this file is too big to fit in your context so grep/search for the relevant sections and read those) 

You can refactor or restructure any part of the codebase if required to avhieve this. You can refactor by merging or breaking existing modules if such an action would faclitate achiving better alignment with the principles discussed. 

--- 


Refine and enhance the plan
Ensure the plan fully leverages all the relevant facilities available in Effect

Read @llms/effect.llms.headline.txt 

To find out the details of something in Effect, read the relevant parts of llms/effect.llms.full.txt (this file is too big to fit in your context so grep/search for the relevant sections and read those) 


ensure your plan leverages as much of the existing codebase as possible, is DRY and aligns with software engineering best practices. Ensure the plan achieves maximal code reuse and code deduplication as much as possible. 

---

I still think the plan is not optimal. Refine and enhance the plan. 
Think like a senior Haskell/Ocaml developer. Ensure your plan aligns with how a senior haskell/ocaml programmer would structure the code, while also respecting my compiler setting @tsconfig.json and ensuring that your plan is compatible with these strict TypeScript settings (I will not be making my settings loose)

----

ensure the plan is exhaustive and idempotent. do not leave any decisions for later. Do the
  required investigation now and ensure the plan is deterministic and complete

---


Ensure your plan achieves a clean refactor, with no legacy code, compatibility bridges, deprecation notices or shims or wrappers letft behind. If there are breaking changes ensure all the callers and tests are updated instead. 

divban is unrelased software and currently has 0 users so we can introduce breaking changes. 

tests are not real consumers. They can be rewritten or adapted as needed. 

---

Â I still feel the plan is not optimal. 

Think like a senior Haskell/OCaml/Scala 3 developer using ZIO and then analyse the existing codebase and see if there is a way to make tthe plan more DRY, more composable and more FP-oriented way while still respecting my TS compiler settings @tsconfig.json

The plan should aim for maximal code reuse 

Launch  at least 6 async background coding agents which should all independently and in in parallel perform this analysis and provide you with the result of their work. Then synthesize all 6 analyses into a coherent and consistent plan which is optimal. 


---

Ensure your plan follows the idiomatic FP-pattern used across the codebase. No loops of any kind are allowed. No mutable data structures are allowed. Business logic and types cannot use "any", "unknown" or "undefined", they are only acceptable on the input side of a vlidation machine, or as internal part of an API when TypeScript's HKT limitations make them unavoidable (the public API should always be fully typed). 

Ensure you plan does not use any switch statements. "if" statemtns are only allowed if evaluating a boolean,  for all other such conditional statements only exhaustive pattern matching using Effect library is allowed. 

Ensure the plan is compatible with my compiler setting @tsconfig.json and ensuring that your plan is compatible with these strict TypeScript settings (I will not be making my settings loose)

--- 

Ensure the plan optimally leverages all the relevant facilities available in Effect

First Read @llms/effect.llms.headline.txt in FULL. This file shows you just the headlines of what' available in Effect. 

Analyse every piece of this documentatgion and ALL of the APIs this library provides and think logically about what APIs could be contained under each headline. . 

Then launch a number of background async agents to analyse the relevant parts of Effect in full. Each agent should independently search for and read the relevant parts of llms/effect.llms.full.txt (this file is too big to fit in context so the background agent should grep/search for the relevant sections and read those). 

Ensure the plan is fully in alignment with the error handling, retry mechanism, and type system used across the codebase. 

--- 

Analyse the documentt @comment-catalogue.md This file is a high level overview of the state of comments in all the typescript files in this repo (excluding tests)

One by one, Open the 5 files which constitute 
Batch 20
in this document. 

Review all the comments in each file in detail. Examine the file does, how it fits in with the codebase, and what that particular function does. Rewrite the comments comprehensively to be concise and to follow software engineering best practices. The comment should describe why the code does what it does, not what it does (which is evident from the code anyway) Think of the libraries which are known for their high quality comments such as Zod, the TypeScript compiler itself and the Effect library and model the comments in these files after them.



Once you have rewritten these comments in this batch, mark the files with a tickbox in @comment-catalogue.md  and then stop. Do not do anything about the other files. Do not change anything other than the commetns of these files. 


---

Analyse this codebase in detail, how it is setup and what it achieves to do. 

I'm now trying to develop a prompt, or an instruction document that I can give to an LLM/AI agent on how to add a service to divban. 

Say I want to give the AI agent a docker compose file I've found on the internet. And I want to tell it to "Add support for X" to divban. And then I want the LLM agent to do everyting correctly, generate the appropriate divban-x.toml file from the docker compose and store it in @examples and then follow all the rules, register things properly, setup all the required commands properly, create all the required services and types and interfaces and anything else that's required so divban then also supports x

I've created two such documents already. Analayse the codebase and then determine which one is better in which regards. Then create an optimised, synthesided new document called
divban-add-service-guide-06.md 
which includes the best parts of the existing documents and removes their weak or incorrect parts. 


--- 

Analyse every single file under the @src directory which has been created or modified since the last commit to git. 

Review all the comments in each file in detail. Examine the file does, how it fits in with the codebase, and what that particular function does. Rewrite the comments comprehensively to be concise and to follow software engineering best practices. The comment should describe why the code does what it does, not what it does (which is evident from the code anyway) Think of the libraries which are known for their high quality comments such as Zod, the TypeScript compiler itself and the Effect library and model the comments in these files after them.

Comments should look like they are written by a senior software engineer, not by an LLM. Avoid intricate ASCII formatting, emojis, etc. 

Rewrite the comments of all of these comprehensively based on the above rules. 